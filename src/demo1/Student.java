package demo1;
//继承的好处
/**
 * 1.提高了代码的复用性
 * 2。让类与类之间产生了关系，给第三个特征多态的特性
 *
 *
 * java中支持单继承，不直接支持多继承，但对c++中的多继承机制进行改良
 * 不直接支持多继承是因为多个父类中有相同成员，会产生调用的不确定性
 *
 * Java支持多重继承，就会出现继承体系，当要使用一个继承体系时{
 *     1.查看该体系中的顶层类，了解该体系的基本功能
 *     2。创建体系中的最子类对象，完成功能的使用
 * }
 *
 * 什么时候定义继承呢{
 *     当类与类之间存在者所属关系的时候，就定义继承，
 * }
 *
 * 当本类的成员和局部变量同名用this区分
 * 当子父类中的成员变量同名用super区分父类
 * this和super的用法很相似{
 *     this代表一个本类对象的引用
 *     super代表一个父类的空间
 * }
 *  成员函数{
 *      当子父类中出现成员函数一摸一样的情况，会运行子类的函数
 *      这种现象，称为覆盖操作，这时函数在子父类中的特性
 *  }
 *  函数的两个特性{
 *      1，重载
 *      2。覆盖
 *  }
 *  覆盖注意事项{
 *      1。子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限
 *      2。静态只能覆盖静态，或被静态覆盖
 *  }
 *
 *  什么时候使用覆盖操作{
 *      当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，
 *      就使用覆盖操作完成
 *  }
 *
 *  子类的实例化过程，子类中所有的构造函数默认都会访问父类中的空参数的构造函数
 *
 *  为什么子类实例化的时候要访问父类中的构造函数呢？{
 *      那是因为子类继承了父类，获取到了父类中的内容（属性）,所以在使用父类内容之前要先看父类是如何对自己
 *      的内容进行初始化的
 *      所以子类在构造对象时，必须访问父类中的构造函数
 *      为什么完成这个必须的动作，就在子类的构造函数中加入super（），语句
 *      如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中哪个构造函数
 *      同时子类构造函数中如果使用this调用本类构造函数时那么super就没有了，应为super和this都只能定义在第一行，所以只能又一个
 *      但是可以保证的是，子类中可定会有其他的构造函数访问父类的构造函数
 *
 *      注意：super语句必须要定义在子类构造函数的第一行，因为父类父类的初始化动作要先完成
 *  }
 *
 *
 * */
class Fu{
    Fu(){
        super();
        show();
        return;
    }
    void show(){
        System.out.println("fu show");
    }
}
class Zi extends Fu{
    int num = 8;
    Zi(){
        super();
        //通过super初始化父类内容时，子类的成员变量并未显示初始化，等super（）父类初始化完毕后
        //才进行子类的成员变量显示初始化
        return;
    }
    void show(){
        System.out.println("zi show..."+num);
    }
}
/**一个对象实例化过程
 * Person p=new Persin();
 * 1,JVM回去读取指定路径下的Person.class文件，并加载进内存
 * 并会先加载Person的父类（如果有直接父类的情况下）
 * 2。在堆内存中开辟空间，分配地址
 * 3。并在对象空间中，对对象中的属性进行默认初始化
 * 4。调用对应的构造函数进行初始化
 * 5。在构造函数中，第一行会先调用父类中的构造函数进行初始化
 * 6。父类初始化完毕后，再对子类的属性进行显示初始化
 * 7。在进行子类构造函数的特定初始化
 * 8。初始化完毕后，将地址值赋值给引用变量
 *
 * */
public class Student {
    public static void main(String args[]){
        Zi z = new Zi();
        z.show();
    }

}
